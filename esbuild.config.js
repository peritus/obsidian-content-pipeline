const { build, context } = require('esbuild');
const { copyFileSync, existsSync, readFileSync, readdirSync, writeFileSync } = require('fs');
const { join } = require('path');

/**
 * Sophisticated esbuild configuration for Obsidian Plugin project
 * Supports environment-based builds, watch mode, file operations, and config injection
 */

// Environment configuration
const OBSIDIAN_CONTENT_PIPELINE_LOGLEVEL = process.env.OBSIDIAN_CONTENT_PIPELINE_LOGLEVEL || 'warn';

// Validate log level
const validLogLevels = ['error', 'warn', 'info', 'debug'];
const logLevel = validLogLevels.includes(OBSIDIAN_CONTENT_PIPELINE_LOGLEVEL.toLowerCase()) 
  ? OBSIDIAN_CONTENT_PIPELINE_LOGLEVEL.toLowerCase() 
  : 'warn';

// Determine if build logging is enabled (for esbuild itself)
const buildLoggingEnabled = ['debug', 'info'].includes(logLevel);

// External dependencies that should not be bundled
const EXTERNAL_DEPS = [
  'obsidian',
  'electron',
  '@codemirror/autocomplete',
  '@codemirror/collab',
  '@codemirror/commands',
  '@codemirror/language',
  '@codemirror/lint',
  '@codemirror/search',
  '@codemirror/state',
  '@codemirror/view',
  '@lezer/common',
  '@lezer/highlight',
  '@lezer/lr'
];

/**
 * Plugin to inject generated configs as virtual modules
 */
const configInjectionPlugin = {
  name: 'config-injection',
  setup(build) {
    // Load generated configs
    const configsDir = join(__dirname, 'build/configs');
    const modelsPath = join(configsDir, 'models.json');
    
    if (!existsSync(modelsPath)) {
      throw new Error(`Generated models config not found at ${modelsPath}. Run 'npm run build:configs' first.`);
    }

    if (!existsSync(configsDir)) {
      throw new Error(`Generated configs directory not found at ${configsDir}. Run 'npm run build:configs' first.`);
    }
    
    // Read shared models config
    const models = JSON.parse(readFileSync(modelsPath, 'utf8'));
    
    // Find and read all pipeline config files
    const configFiles = readdirSync(configsDir);
    const pipelineFiles = configFiles.filter(file => file.endsWith('-pipeline.json'));
    
    const configs = {};
    
    for (const pipelineFile of pipelineFiles) {
      // Extract config name from filename (e.g., 'default-pipeline.json' -> 'default')
      const configName = pipelineFile.replace('-pipeline.json', '');
      const pipelinePath = join(configsDir, pipelineFile);
      
      const pipelineConfig = JSON.parse(readFileSync(pipelinePath, 'utf8'));
      
      configs[configName] = {
        models,
        pipeline: pipelineConfig.pipeline,
        examplePrompts: pipelineConfig.examplePrompts
      };
    }
    
    if (buildLoggingEnabled) {
      console.log('ðŸ“¦ Injecting configs:', Object.keys(configs).join(', '));
    }
    
    // Handle imports of the virtual config module
    build.onResolve({ filter: /^@\/configs$/ }, (args) => {
      return {
        path: args.path,
        namespace: 'config-injection'
      };
    });
    
    build.onLoad({ filter: /.*/, namespace: 'config-injection' }, (args) => {
      return {
        contents: `export const BUNDLED_PIPELINE_CONFIGS = ${JSON.stringify(configs, null, 2)};
export const BUNDLED_MODELS_CONFIG = ${JSON.stringify(models, null, 2)};`,
        loader: 'js'
      };
    });
  }
};

// Build configuration
const buildConfig = {
  entryPoints: ['src/main.ts'],
  outfile: 'main.js',
  platform: 'browser',
  target: 'es2016',
  format: 'cjs',
  treeShaking: true,
  minify: false,
  sourcemap: false,
  external: EXTERNAL_DEPS,
  plugins: [configInjectionPlugin],
  
  // Custom banner with generation warning and project info
  banner: {
    js: `/*
 * WARNING: This file was auto-generated by esbuild
 * Do not edit this file directly - edit the source files instead
 * 
 * Project: Obsidian Content Pipeline Plugin
 * Log Level: ${logLevel}
 * Generated: ${new Date().toISOString()}
 */`
  },
  
  // Environment variable injection
  define: {
    'process.env.OBSIDIAN_CONTENT_PIPELINE_LOGLEVEL': JSON.stringify(logLevel),
    'global': 'globalThis'
  },
  
  // Additional esbuild options
  bundle: true,
  write: true,
  metafile: true,
  logLevel: buildLoggingEnabled ? 'info' : 'warning'
};

/**
 * Copy additional files required for the plugin
 */
async function copyAdditionalFiles() {
  const filesToCopy = [
    { src: 'styles.css', required: false },
    { src: 'manifest.json', required: true }
  ];

  for (const file of filesToCopy) {
    const srcPath = join(__dirname, file.src);
    const destPath = join(__dirname, file.src);
    
    try {
      if (existsSync(srcPath)) {
        copyFileSync(srcPath, destPath);
        if (buildLoggingEnabled) {
          console.log(`âœ“ Copied ${file.src}`);
        }
      } else if (file.required) {
        throw new Error(`Required file ${file.src} not found`);
      } else if (buildLoggingEnabled) {
        console.log(`âš  Optional file ${file.src} not found, skipping`);
      }
    } catch (error) {
      console.error(`âœ— Failed to copy ${file.src}:`, error.message);
      if (file.required) {
        throw error;
      }
    }
  }
}

/**
 * Perform a single build
 */
async function performBuild() {
  if (buildLoggingEnabled) {
    console.log('ðŸ“‹ Build Configuration:');
    console.log(`   Entry: ${buildConfig.entryPoints[0]}`);
    console.log(`   Output: ${buildConfig.outfile}`);
    console.log(`   Platform: ${buildConfig.platform}`);
    console.log(`   Target: ${buildConfig.target}`);
    console.log(`   Format: ${buildConfig.format}`);
    console.log(`   Minify: ${buildConfig.minify}`);
    console.log(`   Tree Shaking: ${buildConfig.treeShaking}`);
    console.log(`   Log Level: ${logLevel}`);
    console.log(`   External Deps: ${EXTERNAL_DEPS.length} packages`);
  }

  try {
    const result = await build(buildConfig);
    
    // Copy additional files
    await copyAdditionalFiles();
    
    // Success logging
    console.log('âœ… Build completed successfully!');
    
    if (buildLoggingEnabled && result.metafile) {
      console.log('ðŸ“Š Build Statistics:');
      const outputs = Object.keys(result.metafile.outputs);
      outputs.forEach(output => {
        const size = result.metafile.outputs[output].bytes;
        console.log(`   ${output}: ${(size / 1024).toFixed(2)} KB`);
      });
      writeFileSync('build/meta.json', JSON.stringify(result.metafile));
    }
    
    return result;
  } catch (error) {
    console.error('âŒ Build failed:', error.message);
    throw error;
  }
}

/**
 * Main build function with command-line argument support
 */
async function main() {
  const args = process.argv.slice(2);
  const isWatchMode = args.includes('--watch') || args.includes('-w');
  
  console.log('ðŸš€ Obsidian Content Pipeline Plugin Build System');
  console.log(`ðŸ“… Build started at: ${new Date().toLocaleString()}`);
  console.log(`ðŸ“Š Log Level: ${logLevel.toUpperCase()}`);
  console.log('â”€'.repeat(50));
  
  try {
    await performBuild();
  } catch (error) {
    console.error('\nðŸ’¥ Build process failed:', error.message);
    
    if (buildLoggingEnabled) {
      console.error('Stack trace:', error.stack);
    }
    
    process.exit(1);
  }
}

// Execute the build if this file is run directly
if (require.main === module) {
  main().catch(error => {
    console.error('Unhandled error:', error);
    process.exit(1);
  });
}

module.exports = {
  buildConfig,
  performBuild,
  main
};