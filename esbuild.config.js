const { build, context } = require('esbuild');
const { copyFileSync, existsSync } = require('fs');
const { join } = require('path');

/**
 * Sophisticated esbuild configuration for Obsidian Plugin project
 * Supports environment-based builds, watch mode, and file operations
 */

// Environment configuration
const OBSIDIAN_AUDIO_INBOX_LOGLEVEL = process.env.OBSIDIAN_AUDIO_INBOX_LOGLEVEL || 'warn';
const NODE_ENV = process.env.NODE_ENV || 'development';
const isProduction = NODE_ENV === 'production';

// Validate log level
const validLogLevels = ['error', 'warn', 'info', 'debug'];
const logLevel = validLogLevels.includes(OBSIDIAN_AUDIO_INBOX_LOGLEVEL.toLowerCase()) 
  ? OBSIDIAN_AUDIO_INBOX_LOGLEVEL.toLowerCase() 
  : 'warn';

// Determine if build logging is enabled (for esbuild itself)
const buildLoggingEnabled = ['debug', 'info'].includes(logLevel);

// External dependencies that should not be bundled
const EXTERNAL_DEPS = [
  'obsidian',
  'electron',
  '@codemirror/autocomplete',
  '@codemirror/collab',
  '@codemirror/commands',
  '@codemirror/language',
  '@codemirror/lint',
  '@codemirror/search',
  '@codemirror/state',
  '@codemirror/view',
  '@lezer/common',
  '@lezer/highlight',
  '@lezer/lr'
];

// Build configuration
const buildConfig = {
  entryPoints: ['src/main.ts'],
  outfile: 'main.js',
  platform: 'browser',
  target: 'es2016',
  format: 'cjs',
  treeShaking: true,
  minify: isProduction,
  sourcemap: !isProduction,
  external: EXTERNAL_DEPS,
  
  // Custom banner with generation warning and project info
  banner: {
    js: `/*
 * WARNING: This file was auto-generated by esbuild
 * Do not edit this file directly - edit the source files instead
 * 
 * Project: Obsidian Audio Inbox Plugin
 * Build Mode: ${NODE_ENV}
 * Log Level: ${logLevel}
 * Generated: ${new Date().toISOString()}
 */`
  },
  
  // Environment variable injection
  define: {
    'process.env.NODE_ENV': JSON.stringify(NODE_ENV),
    'process.env.OBSIDIAN_AUDIO_INBOX_LOGLEVEL': JSON.stringify(logLevel),
    'global': 'globalThis'
  },
  
  // Additional esbuild options
  bundle: true,
  write: true,
  metafile: true,
  logLevel: buildLoggingEnabled ? 'info' : 'warning'
};

/**
 * Copy additional files required for the plugin
 */
async function copyAdditionalFiles() {
  const filesToCopy = [
    { src: 'styles.css', required: false },
    { src: 'manifest.json', required: true }
  ];

  for (const file of filesToCopy) {
    const srcPath = join(__dirname, file.src);
    const destPath = join(__dirname, file.src);
    
    try {
      if (existsSync(srcPath)) {
        copyFileSync(srcPath, destPath);
        if (buildLoggingEnabled) {
          console.log(`✓ Copied ${file.src}`);
        }
      } else if (file.required) {
        throw new Error(`Required file ${file.src} not found`);
      } else if (buildLoggingEnabled) {
        console.log(`⚠ Optional file ${file.src} not found, skipping`);
      }
    } catch (error) {
      console.error(`✗ Failed to copy ${file.src}:`, error.message);
      if (file.required) {
        throw error;
      }
    }
  }
}

/**
 * Perform a single build
 */
async function performBuild() {
  console.log(`🔨 Building Obsidian Audio Inbox Plugin (${NODE_ENV} mode)`);
  
  if (buildLoggingEnabled) {
    console.log('📋 Build Configuration:');
    console.log(`   Entry: ${buildConfig.entryPoints[0]}`);
    console.log(`   Output: ${buildConfig.outfile}`);
    console.log(`   Platform: ${buildConfig.platform}`);
    console.log(`   Target: ${buildConfig.target}`);
    console.log(`   Format: ${buildConfig.format}`);
    console.log(`   Minify: ${buildConfig.minify}`);
    console.log(`   Tree Shaking: ${buildConfig.treeShaking}`);
    console.log(`   Log Level: ${logLevel}`);
    console.log(`   External Deps: ${EXTERNAL_DEPS.length} packages`);
  }

  try {
    const result = await build(buildConfig);
    
    // Copy additional files
    await copyAdditionalFiles();
    
    // Success logging
    console.log('✅ Build completed successfully!');
    
    if (buildLoggingEnabled && result.metafile) {
      console.log('📊 Build Statistics:');
      const outputs = Object.keys(result.metafile.outputs);
      outputs.forEach(output => {
        const size = result.metafile.outputs[output].bytes;
        console.log(`   ${output}: ${(size / 1024).toFixed(2)} KB`);
      });
    }
    
    return result;
  } catch (error) {
    console.error('❌ Build failed:', error.message);
    throw error;
  }
}

/**
 * Start watch mode for development
 */
async function startWatchMode() {
  console.log('👀 Starting watch mode for Obsidian Audio Inbox Plugin...');
  
  try {
    const ctx = await context(buildConfig);
    
    // Copy files initially
    await copyAdditionalFiles();
    
    await ctx.watch();
    console.log('✅ Watch mode started. Waiting for changes...');
    
    // Keep the process alive
    process.on('SIGINT', async () => {
      console.log('\n🛑 Stopping watch mode...');
      await ctx.dispose();
      process.exit(0);
    });
    
  } catch (error) {
    console.error('❌ Watch mode failed:', error.message);
    throw error;
  }
}

/**
 * Main build function with command-line argument support
 */
async function main() {
  const args = process.argv.slice(2);
  const isWatchMode = args.includes('--watch') || args.includes('-w');
  
  console.log('🚀 Obsidian Audio Inbox Plugin Build System');
  console.log(`📅 Build started at: ${new Date().toLocaleString()}`);
  console.log(`🌍 Environment: ${NODE_ENV}`);
  console.log(`📊 Log Level: ${logLevel.toUpperCase()}`);
  console.log('─'.repeat(50));
  
  try {
    if (isWatchMode) {
      await startWatchMode();
    } else {
      await performBuild();
    }
  } catch (error) {
    console.error('\n💥 Build process failed:', error.message);
    
    if (buildLoggingEnabled) {
      console.error('Stack trace:', error.stack);
    }
    
    process.exit(1);
  }
}

// Execute the build if this file is run directly
if (require.main === module) {
  main().catch(error => {
    console.error('Unhandled error:', error);
    process.exit(1);
  });
}

module.exports = {
  buildConfig,
  performBuild,
  startWatchMode,
  main
};